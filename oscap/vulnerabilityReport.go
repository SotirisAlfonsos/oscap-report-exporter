package oscap

import (
    "fmt"
    "github.com/go-kit/kit/log"
    "github.com/go-kit/kit/log/level"
    "github.com/pkg/errors"
    "io"
    "net/http"
    "os"
    "time"
)

var downloadRetry = 3

// VulnerabilityReport contains the details for the location of the global Reh Hat vulnerability report
type VulnerabilityReport struct {
    GlobalVulnerabilityReportHTTPSLocation string `yaml:"global_vulnerability_report_https_location"`
    UserName                               string `yaml:"username"`
    Password                               string `yaml:"password"`
}

// DownloadFile handles the download of the global vulnerability report from the Rhel site
func (vrep *VulnerabilityReport) DownloadFile(filepath string, logger log.Logger) error {
    // Create the file with .tmp extension, so that we won't overwrite a
    // file until it's downloaded fully
    url := vrep.GlobalVulnerabilityReportHTTPSLocation

    if url != "" {
        level.Info(logger).Log("msg", "preparing file download")

        level.Debug(logger).Log("msg", "Creating file "+filepath+".tmp")

        out, err := os.Create(filepath + ".tmp")
        if err != nil {
            return errors.Wrap(err, "could not create tmp file "+filepath+".tmp")
        }
        defer out.Close()

        // Get the data
        level.Debug(logger).Log("msg", "Downloading file from "+url)
        req, err := http.NewRequest("GET", url, nil)
        if err != nil {
            return errors.Wrap(err, "could not create new request for url "+url)
        }

        req.SetBasicAuth(vrep.UserName, vrep.Password)

        client := &http.Client{}
        resp, err := vrep.downloadManager(client, req, downloadRetry, logger)
        if err != nil {
            return errors.Wrap(err, "failed when downloading the global vulnerabilities file from "+url)
        }
        defer resp.Body.Close()

        // Create our bytes counter and pass it to be used alongside our writer
        counter := &WriteCounter{}
        if _, err = io.Copy(out, io.TeeReader(resp.Body, counter)); err != nil {
            return errors.Wrap(err, "failed to write response to file")
        }

        // Print a confirmation once the download is finished
        level.Debug(logger).Log("msg", "download completed")

        // Rename the tmp file back to the original file
        if err = os.Rename(filepath+".tmp", filepath); err != nil {
            return errors.Wrap(err, "failed when renaming file "+filepath+".tmp to "+filepath)
        }
    }

    return nil
}

// WriteCounter counts the number of bytes written to it.
type WriteCounter struct {
    Total uint64
}

func (wc *WriteCounter) Write(p []byte) (int, error) {
    n := len(p)
    wc.Total += uint64(n)
    return n, nil
}

func (vrep *VulnerabilityReport) downloadManager(client *http.Client, req *http.Request, retry int, logger log.Logger) (*http.Response, error) {
    level.Debug(logger).Log("msg", "trying to download")
    resp, err := client.Do(req)
    if (err != nil || resp.StatusCode >= 400) && retry > 0 {
        level.Warn(logger).Log("msg", "failed to download with code "+fmt.Sprint(resp.StatusCode)+". retrying..")
        time.Sleep(15 * time.Second)

        return vrep.downloadManager(client, req, retry-1, logger)
    } else if retry == 0 && err == nil {
        return resp, errors.New("Could not download file")
    }
    return resp, err
}
