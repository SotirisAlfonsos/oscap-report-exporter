package oscap

import (
    "io"
    "time"
    "net/http"
    "os"
	"log"
)

type VulnerabilityReport struct {
	GlobalVulnerabilityReportHttpsLocation string `yaml:"global_vulnerability_report_https_location"`
	UserName string `yaml:"username"`
	Password string `yaml:"password"`
	BaseVulnerabilityReportUrl string `yaml:"base_vulnerability_report_url"`
}

func (vrep *VulnerabilityReport) DownloadFile(filepath string, retry int) error{
	// Create the file with .tmp extension, so that we won't overwrite a
    // file until it's downloaded fully
    url := vrep.BaseVulnerabilityReportUrl + vrep.GlobalVulnerabilityReportHttpsLocation
	log.Printf("Creating file " + filepath + ".tmp")
    out, err := os.Create(filepath + ".tmp")
    if err != nil {
        log.Printf("Error: Could not create tmp file " + filepath + ".tmp")
        return err
    }
    defer out.Close()

    // Get the data
    log.Printf("Downloading file from " + url)
    client := &http.Client{}
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        log.Printf("Error: Could not create new request for url " + url)
        return err
    }
    
    req.SetBasicAuth(vrep.UserName, vrep.Password)
    
    resp, respErr := vrep.downloadManager(client, req, retry)
    if respErr != nil {
        log.Printf("Error: Failed when downloading the global vulnerabilities file from " + url + " with code " + string(resp.StatusCode) )
        return respErr
    }

    defer resp.Body.Close()

    // Create our bytes counter and pass it to be used alongside our writer
    counter := &WriteCounter{}
    _, err = io.Copy(out, io.TeeReader(resp.Body, counter))
    if err != nil {
        log.Printf("Error: Failed to write response to file ")
        return err
    }

    // Print a confirmation once the download is finished
    log.Printf("Download completed.")

    // Rename the tmp file back to the original file
    err = os.Rename(filepath+".tmp", filepath)
    if err != nil {
        log.Printf("Error: Failed when renaming file " + filepath + ".tmp to " + filepath)
        return err
    }

    return nil
}

type WriteCounter struct {
    Total uint64
}

func (wc *WriteCounter) Write(p []byte) (int, error) {
    n := len(p)
    wc.Total += uint64(n)
    return n, nil
}

func (vrep *VulnerabilityReport) downloadManager(client *http.Client, req *http.Request, retry int) (*http.Response, error) {
	resp, err := client.Do(req)
	log.Printf("Tying to download")
    if (err != nil || resp.StatusCode >= 400) && retry > 0 {
    	log.Printf("Failed to download. Retrying ")
    	time.Sleep(60 * time.Second)

    	return vrep.downloadManager(client, req, retry-1)
    }
    return resp, err
}